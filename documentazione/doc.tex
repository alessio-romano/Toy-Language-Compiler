% !TEX encoding = UTF-8 Unicode
% !TEX TS-program = pdflatex
% !TeX spellcheck = it-IT
% Preambolo
\documentclass[a4paper,12pt]{article}
\pagestyle{plain}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{geometry}
\usepackage{amssymb}
\usepackage{amsmath} % per i simboli matematici
\geometry{a4paper,top=2.5cm,bottom=2.5cm,left=2cm,right=2cm,heightrounded,bindingoffset=5mm}
\usepackage{microtype} % per migliorare il riempimento delle righe
\usepackage{setspace} % per l'interlinea
\onehalfspacing
\usepackage{xcolor} % per i colori
\usepackage{booktabs} % per le tabelle
\usepackage{multirow}
\usepackage{caption}
\usepackage{subfig}
% per i link
\usepackage{hyperref}
\hypersetup{
  colorlinks   = true,    % Colours links instead of ugly boxes
  urlcolor     = blue,    % Colour for external hyperlinks
  linkcolor    = black,    % Colour of internal links
  citecolor    = red      % Colour of citations
}
\usepackage[english, italian]{babel}
\newcommand\resw[1]{\mathtt{#1}}
\newcommand\mi[1]{\mathit{#1}}
%Comandi per Grammatica
\newcommand\nonterm[1]{\texttt{\textcolor{violet}{#1}}}
\newcommand\term[1]{\texttt{\textcolor{teal}{#1}}}
\newcommand\production[1]{\texttt{#1} \texttt{:=}}
\newcommand\emptyprod{\texttt{\textcolor{teal}{/* empty */}}}
\title{Progetto Compilatori \\ \normalsize{A.A. 2020/2021}}
\author{Gaetano Antonucci \and Alessio Romano}
\date{\today}
\begin{document}
    \maketitle
    \tableofcontents
    \newpage
    
    \section{Grammatica Utilizzata}
    \begin{tabular}{rl}
    	\production{Program}     & \nonterm{VarDeclList} \nonterm{ProcList} \\
	\production{VarDeclList} & \nonterm{VarDecl} \nonterm{VarDeclList} \\
	                                     | & \emptyprod \\
	\production{VarDecl}      & \nonterm{Type} \nonterm{IdListInit} \term{SEMI} \\
	\production{Type}           & \term{INT} \\ 
					   | &\term{BOOL} \\ 
					   | &\term{FLOAT} \\
					   | &\term{STRING} \\
	\production{IdListInit}     &\term{ID} \\
					   |&\nonterm{IdListInit} \term{COMMA} \term{ID} \\
					   |&\term{ID} \term{ASSIGN} \nonterm{Expr} \\
					   |&\nonterm{IdListInit} \term{COMMA} \term{ID} \term{ASSIGN} \nonterm{Expr} \\
	\production{ProcList}    &\nonterm{Proc} \\
					  |&\nonterm{Proc} \nonterm{ProcList} \\
	\production{Proc}         & \term{PROC} \term{ID} \term{LPAR} \nonterm{ParamDeclList} \term{RPAR} \nonterm{ResultTypeList} \term{COLON} %
						\nonterm{ProcBody}\\
					  |& \term{PROC} \term{ID} \term{LPAR} \term{RPAR} \nonterm{ResultTypeList} \term{COLON} \nonterm{ProcBody}\\
	\production{\textcolor{blue}{ProcBody}} & \nonterm{VarDeclList} \nonterm{StatList} \term{RETURN} \nonterm{ReturnExprs} \term{CORP} \term{SEMI} \\
	 				  |& \nonterm{VarDeclList} \term{RETURN} \nonterm{ReturnExprs} \term{CORP} \term{SEMI} \\
	\production{ParamDeclList} & \nonterm{ParDecl} \\
						  |& \nonterm{ParamDeclList} \term{SEMI} \nonterm{ParDecl} \\
	\production{ParDecl}            & \nonterm{Type} \nonterm{ParIdList} \\
	\production{\textcolor{blue}{ParIdList}}           & \term{ID} \\
						  |& \nonterm{ParIdList} \term{COMMA} \term{ID} \\
	\production{ResultTypeList} & \nonterm{ResultType} \\
						  |& \nonterm{ResultType} \term{COMMA} \nonterm{ResultTypeList} \\
	\production{ResultType}       & \nonterm{Type} \\
						  |& \term{VOID} \\
	\production{StatList} 		   & \nonterm{Stat} \term{SEMI} \\
						  |& \nonterm{Stat} \term{SEMI} \nonterm{StatList} \\
	\production{Stat}                  & \nonterm{IfStat} \\
						  |& \nonterm{WhileStat} \\
						  |& \nonterm{ReadlnStat} \\
						  |& \nonterm{AssignStat} \\
						  |& \nonterm{CallProc} \\
    \production{IfStat}                   & \term{IF} \nonterm{Expr} \term{THEN} \nonterm{StatList} \nonterm{ElifList} \nonterm{Else} \term{FI} \\
    \production{ElifList}                 & \nonterm{Elif} \nonterm{ElifList} \\
    						|& \emptyprod \\
    \end{tabular}
    %
    \begin{tabular}{rl}
   \production{Elif}			 & \term{ELIF} \nonterm{Expr} \term{THEN} \nonterm{StatList} \\
   \production{Else}   			 & \term{ELSE} \nonterm{StatList} \\
   						|& \emptyprod \\
   \production{WhileStat}             & \term{WHILE} \nonterm{StatList} \term{RETURN} \nonterm{Expr} \term{DO} \nonterm{StatList} \term{OD} \\
   						|& \term{WHILE} \nonterm{Expr} \term{DO} \nonterm{StatList} \term{OD} \\
  \production{ReadlnStat}           & \term{READ} \term{LPAR} \nonterm{IdList} \term{RPAR} \\
  \production{IdList}                    & \term{ID} \\
					        |& \nonterm{IdList} \term{COMMA} \term{ID} \\
  \production{WriteStat}              & \term{WRITE} \term{LPAR} \nonterm{ExprList} \term{RPAR} \\
  \production{AssignStat}           & \nonterm{IdList} \term{ASSIGN} \nonterm{ExprList} \\
  \production{CallProc}         & \term{ID} \term{LPAR} \nonterm{ExprList} \term{RPAR} \\
						|& \term{ID} \term{LPAR} \term{RPAR} \\
  \production{ReturnExprs}    & \nonterm{ExprList} \\
						 |& \emptyprod \\
	\production{ExprList}           & \nonterm{Expr} \\
						 |& \nonterm{Expr} \term{COMMA} \nonterm{ExprList} \\
   \production{Expr}                    & \term{NULL} \\
						|& \term{TRUE} \\
						|& \term{FALSE} \\
						|& \term{INT\_CONST} \\
						|& \term{FLOAT\_CONST} \\
						|& \term{STRING\_CONST} \\
						|& \term{ID} \\
    				                 |& \term{MINUS} \nonterm{Expr} \\
						|& \nonterm{Expr} \term{PLUS} \nonterm{Expr} \\
						|& \nonterm{Expr} \term{MINUS} \nonterm{Expr} \\ 
						|& \nonterm{Expr} \term{TIMES} \nonterm{Expr} \\
						|& \nonterm{Expr} \term{DIV} \nonterm{Expr} \\
    						|& \term{NOT} \nonterm{Expr} \\
						|& \nonterm{Expr} \term{AND} \nonterm{Expr} \\
						|& \nonterm{Expr} \term{OR} \nonterm{Expr} \\
						|& \nonterm{Expr} \term{GT} \nonterm{Expr} \\
						|& \nonterm{Expr} \term{GE} \nonterm{Expr} \\
						|& \nonterm{Expr} \term{LT} \nonterm{Expr} \\
						|& \nonterm{Expr} \term{LE} \nonterm{Expr} \\
						|& \nonterm{Expr} \term{EQ} \nonterm{Expr} \\
						|& \nonterm{Expr} \term{NE} \nonterm{Expr} \\
						|& \nonterm{CallProc} \\
    \end{tabular}
    \section{Regole di Type Checking implementate}
    \subsection{Tipi Primitivi}
    \[
        \Gamma \vdash null \colon null \qquad
        \Gamma \vdash true \colon boolean \qquad
        \Gamma \vdash false \colon boolean \qquad
    \]
    \[
        \Gamma \vdash \mi{int} \colon int \qquad
        \Gamma \vdash \mi{float} \colon float \qquad
        \Gamma \vdash \mi{string} \colon string \qquad
        \Gamma \vdash \mi{bool}    \colon boolean \qquad
    \]
    \subsection{Dichiarazioni di Variabili}
    \[
        \frac{(x \colon \tau) \in \Gamma}{\Gamma \vdash x \colon \tau}
    \]
    \subsection{Operazioni Unarie}
    \[
        \frac {\Gamma \vdash \mi{e} \colon \tau_1 \quad optype1(op,\tau_1) = \tau} %
              {\Gamma \vdash (op \, \mi{e}) \colon \tau}
    \]
    \subsection{Operazioni Binarie}
    \[
        \frac {\Gamma \vdash \mi{e_1} \colon \tau_1 \quad \Gamma \vdash \mi{e_2} \colon \tau_2  \quad optype2(op,\tau_1, \tau_2) = \tau} %
        {\Gamma \vdash (\mi{e_1}\, op \, \mi{e_2}) \colon \tau}
    \]
    \subsection{Chiamata a Procedura}
    \[
        \frac {\Gamma \vdash \mi{f} \colon \tau_i^{\,i \, \in \,1 \, \dots \, n} \to \tau_j^{\,j \, \in \, 1 \, \dots \, m} \quad \Gamma \vdash \mi{e_i} \colon %
        \tau_i^{\, i \, \in \, 1 \, \dots \, n}} %
        {\Gamma \vdash \mi{f}(\mi{e}_i^{\, i \, \in \, 1 \, \dots \, n})\colon \tau_j^{\, j \, \in \, 1 \, \dots \, m}}
    \]
    
    \subsection{Statement}
    	\subsubsection{if-then}
	\[
		\frac{\Gamma \vdash \mi{e} \colon boolean \quad \Gamma \vdash \mi{stmt}}%
		{\Gamma \vdash \resw{if} \, \mi{e} \, \resw{then} \, \mi{stmt} \, \resw{fi}}
	\]
	\subsubsection{if-then-else}
	\[
		\frac{\Gamma \vdash \mi{e} \colon boolean \quad \Gamma \vdash \mi{stmt}_{1} \quad \Gamma \vdash \mi{stmt}_{2}}%
		{\Gamma \vdash \resw{if} \, \mi{e} \, \resw{then} \, \mi{stmt}_{1} \, \resw{else} \, \mi{stmt}_{2} \, \resw{fi}}
	\]
	\subsubsection{if-then-elif-else}
	\[
		\frac{\Gamma \vdash \mi{e}_{j}^{\, j \, \in \, 1 \, \dots \, m} \colon boolean \quad %
		\Gamma \vdash \mi{stmt}_{i}^{i \, \in \, 1 \, \dots \, 3}}%
		{%denominatore
		\Gamma \vdash  \resw{if} \, \mi{e}_{1} \, \resw{then} \, \mi{stmt}_{1}  \,
		 (\resw{elif} \, \mi{e}_{j}^{\, j \, \in \, 2 \, \dots \, m} \, \resw{then} \, \mi{stmt}_{2}\,)_{t}^{t \, \in \, 1 \, \dots \, k} \,
		  \resw{else} \, \mi{stmt}_{3} \, \resw{fi}
		}%
	\]
	\subsubsection{while}
	\[
		\frac{\Gamma \vdash \mi{e} \colon boolean \quad \Gamma \vdash \mi{stmt}}%
		{\Gamma \vdash \resw{while} \, \mi{e} \, \resw{do}\, \mi{stmt} \, \resw{od}}
	\]
	\subsubsection{while-return}
	\[
		\frac{\Gamma \vdash \mi{e} \colon boolean \quad \Gamma \vdash \mi{stmt}_{1} \quad \Gamma \vdash \mi{stmt}_{2}}%
		{\Gamma \vdash \resw{while} \, \mi{stmt}_{1}  \resw{-\!\!>}\, \mi{e} \, \resw{do}\, \mi{stmt}_{2} \, \resw{od}}
	\]
	\subsubsection{readln}
	\[
		\frac{(x_{i}^{\, i \, \in \, 1 \, \dots \, n} \colon \tau_{i}^{\, i \, \in \, 1 \, \dots \, n}) \, \in \, \Gamma}%
		{\Gamma \vdash \resw{readln(} \mi{x}_{i}^{\, i \, \in \, 1 \, \dots \, n} \resw{)}}
	\]
    \subsubsection{write}
    \[
        \frac{\Gamma \vdash \mi{e} \colon \tau \quad (\tau \neq \resw{void})\footnotemark}%
        {\Gamma \vdash \resw{write(} \mi{e} \colon \tau \resw{)}}
    \]
    \footnotetext{Si vuole intendere che il tipo di $e$ deve essere diverso da \texttt{void}. Per ulteriori 
    informazioni consultare le scelte di sviluppo del compilatore.}
    \subsubsection{simple-assign}
    \[
        \frac{(\mi{x} \colon \tau) \, \in \, \Gamma \quad \Gamma \vdash \mi{e} \colon \tau}%
        {\Gamma \vdash \mi{x} \, \resw{:=} \, \mi{e}}
    \]
    \subsubsection{multiple-assign}
     \[
        \frac{(\mi{x}_{i}^{\, i \, \in \, 1 \, \dots \, n} \colon \tau_{i}^{\, i \, \in \, 1 \, \dots \, n}) \, \in \, \Gamma \quad \Gamma \vdash \mi{e}_{j}^{\, j \, \in \, 1 \, \dots \, n}% 
        \colon \tau_{j}^{\, j \, \in \, 1 \, \dots \, n}}%
        {\Gamma \vdash \mi{x}_{i}^{\, i \, \in \, 1 \, \dots \, n} \, \resw{:=} \, \mi{e}_{j}^{\, j \, \in \, 1 \, \dots \, n}}
    \]
    \subsubsection{return}
    \[
    	\frac{(\$\mi{ret} \colon \tau) \in \Gamma \quad \Gamma \vdash \mi{e} \colon \tau}%
	{\Gamma \vdash \resw{-\!\!>} \mi{e}}
    \]
    \subsection{Tabelle di Compatibilità}
    \begin{figure}[ht]
    	\centering
	\subfloat[][optype1]{%
    	\begin{tabular}{lll}
    		\toprule
		op & operand & result\\
		\midrule
		- & integer & integer \\
		- & float     & float \\
		! & boolean & boolean \\
		\bottomrule
    	\end{tabular}
    	} \\
	
	\subfloat[][optype2]{%
	\begin{tabular}{llll}
		\toprule
		\multicolumn{1}{c}{\multirow{2}*{op}} & \multicolumn{1}{c}{first}  & \multicolumn{1}{c}{second} & \multicolumn{1}{c}{\multirow{2}*{result}} \\
		                      & \multicolumn{1}{c}{operand} & \multicolumn{1}{c}{operand} \\
		\midrule
		+ - * / & integer & integer & integer \\
		+ - * / & integer & float & float \\
		+ - * / & float & integer & float \\
		+ - * / & float & float & float \\
		\&\& || & boolean & boolean & boolean\\
		< = > <= >= <> & integer & integer & boolean \\
		< = > <= >= <> & integer & float & boolean \\
		< = > <= >= <> & float & integer & boolean \\
		< = > <= >= <> & float & float & boolean \\
		< = > <= >= <> & string & string & boolean \\
		\bottomrule
	\end{tabular}
	}
	\caption{Relazioni di tipo per gli operatori primitivi. Gli operatori aritmetici lavorano sia su numeri interi sia su numeri in virgola mobile.
	              Gli operatori logici ! \&\& || (not, and e or) lavorano su boolean. Gli operatori di comparazione lavorano su tipi primitivi diversi da boolean.}
\end{figure}
    
% Note sul Lexer:
% - sono stati usati i singoli casi per gli operatori di comparazione (LT, GT, ecc.) al posto del singolo RELOP
% - abbiamo usato tre stati di Jflex per gestire i commenti (stati COMMENT e COMMENT2) e per le stringhe (stato STRING)
%	per la rilevazione agevole degli errori.
% - In un primo momento (es4 e es3) si era deciso di non permettere di avere numeri in virgola mobile di questo tipo:
% 	34.0; ci si è resi conto poi che era troppo limitante e quindi è stata modificata la reg exp.
% -	Nel caso di stringhe, si è dovuto gestire caso per caso i simboli non stampabili \n \r \t in quanto venivano
%	riconosciuti anche quelli naturalmente presenti nel file sorgente.
%
% Note sul Parser:
% - Le modifiche apportate alla grammatica non modificano il linguaggio generato rispetto alla grammatica fornita
%	Ciò è stato fatto per gestire in maniera più agevole le azioni semantiche da svolgere.
% - Si è deciso di gestire gli scope già nel parser (azioni semantiche nel corpo di una produzione e non solo alla fine)
% 	--> Grammatica non post-fissa
%
% Analisi Sintattica:
% - è stato generato l'AST tramite patter Visitor (creato il file xml)
% 	Per la gestione delle componenti dell'albero sintattico, si è optato per l'utilizzo di una classe padre
%	(la classe Node.java) contenente l'elemento nome in quanto comune a tutte le componenti. Ogni classe
%	rappresentante una componente diversa dell'albero, quindi, estende la classe Node.java
% 	Ragionamento analogo al punto precedente, è stato fatto per le classi che rappresentano gli Statement del
%	linguaggio di programmazione Toy. In questo caso, la classe padre è StatOp.java
%	Siccome ci sono alcune componenti dell'albero sintattico che sono comuni a più produzioni della grammatica,
%	si è scelto di avere, Expr e IdListInit come interfacce. Questo perché, ad esempio, ID (che corrisponde ad
%	una foglia dell'albero) può essere sia visto come Expr sia come un elemento di IdListInit.
%	Ciò è stato fatto per ottenere, ad esempio, una lista di Expr i cui elementi sono eterogenei (e anche perché in
%	Java non esiste l'ereditarietà multipla).
%	Per applicare il pattern Visitor, si è utilizzata l'interfaccia Visitor.java che, per nostra scelta,
%	contiene le firme distinte dei vari metodi visit(), ognuno dei quali è specifico per una componente
%	dell'albero sintattico.
%
%	Per la generazione del file XML si è utilizzata la libreria jdom
%	(v 2.0.6) inserita come external library

% Analizzatore Semantico:
% - L'analisi semantica viene effettuata utilizzando due visite dell'AST
% - La prima serve ad aggiungere informazioni che servono per il type checking alla symbol table
% - La seconda esegue il type checking + controllo del singolo main + dichiarazioni nei diversi scope
% - è stata utilizzata la forward reference per le procedure quindi non è strettamente necessario
%	dichiararle prima del loro uso

% Generazione del codice intermedio:
% - gestione dei ritorni multipli
% - assegnazione multipla (e con procedure con ritorni multipli)
% - main che restituisce int (firma del main fissa in toy)
% - trasformazione del while
%    * Nel caso 1, il codice C risultante è il seguente:
%         *
%         * statements1
%         * while(expr){
%         *    statements2
%         *    statements1
%         * }
%         * Nel caso 2, il codice C risultante è il seguente:
%         *
%         * while(condizione){
%         *  statements
%         * }s
% La Symbol Table viene riportata anche in un file di testo
\end{document}